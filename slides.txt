===================================
Verification and Validation of MOM6
===================================

:authors:
   - Alistair Adcroft
   - Robert Hallberg
   - **Marshall Ward**
:description: An overview of the MOM6 testing framework
:date: 2020 June 8


----

**Verification**

   Am I building the product right?

**Validation**

   Am I building the right product?

Barry Boehm, *Software Risk Management* (1989)


Verification
============

What are the *design specifications* of my model?

* Does it compile on target platforms?
* Are the equations dimensionally consistent?
* Does parallelization change the answers?

*Verification is the confirmation of design specifications.*


Validation
==========

Does our model meet operational needs?

* Does it produce realistic simulations?
* Are relevant physical features present?
* Can I reproduce my old simulations?

*Validation is an assessment of the final product.*


V&V in Development
==================

.. list-table::

   * - .. figure:: img/waterfall.svg
          :width: 60%
          :target: https://en.wikipedia.org/wiki/File:Waterfall_model.svg

          Waterfall

     - .. figure:: img/v_model.svg
          :target: https://commons.wikimedia.org/wiki/File:Systems_Engineering_Process_II.svg

          V-model

.. figure:: img/agile.jpeg
   :width: 50%
   :target: https://medium.com/open-product-management/crash-article-in-agile-development-da960861259e


.. notes::
   All software development models rely on some form of verification or
   validation.

   The waterfall method (upper left) has a single stage of development, like
   building a bridge or launching a space rocket, so validation is not
   possible.  Verification must be extremely thorough.

   More iterative models like the V-model treat the development process as
   verification, and then use validation to re-define the verification steps.

   Modern Agile methods define multiple development cycles, including
   verification and validation after each "scrum".  Scrum-like methods can
   blur the distinction between verification and validation.


V&V in MOM6
===========

.. image:: img/mom_submit.svg
   :width: 20%
   :class: float

* Fork from a community repository

* Apply any modifications

* Submit as Pull Request™

* Trigger V&V events

  * Automated verification

  * Manual validation

All contributions must pass verification and validation before merge.

.. notes::

   A contributer first creates a fork of the active development branch, say
   ``dev/gfdl``.

   Contributor works on their new feature.  Meanwhile, ``dev/gfdl`` is also
   evolving.

   Once completed, the contributer submits it as a Pull Request via GitHub.

   The submission must meet the design criteria of the source code.  This is
   satisfied by pass through verification and validation before being
   considered for contribution.


MOM6 Verification
=================

.. image:: img/mom_verify.svg
   :width: 35%
   :class: float

Verification is automatically submitted to a CI (e.g. Travis)

* Build all compile-time configs

* Setup test configurations

* Run invariance tests

All builds must pass verification.



Verification Tests
------------------

.. TODO This is too long!

==========  =================================
Test        Description
==========  =================================
grid        Symmetric/Asymmetric memory grids
layout      1×1 and 2×1 domain decomposition
rotation    Index rotation
restart     Restart at mid-run
repro       Optimized reproducible mode
openmp      OpenMP (single-thread)
nan         NaN array initialization
dim         Dimensional scaling
==========  =================================

Each test requires bit reproducibility


Tests in Action
===============

(TODO: make this pretty)

A successful test:

   https://travis-ci.org/github/marshallward/MOM6/jobs/687171621

A failed test:

   https://travis-ci.org/github/marshallward/MOM6/jobs/687177632


MOM6 Validation
===============

.. image:: img/mom_validate.svg
   :width: 50%
   :class: float

TODO

* Site-specific

* Gaea Pipeline

* Human validation


Hub Validation
==============

.. image:: img/gitrepos.svg
   :width: 50%
   :class: float

Local contributions accumulate over time, becoming a ``dev/master`` PR.

Local hub submits PR, and each hub validates the PR.

Upon consensus, PR is merged into ``dev/master``.


Bit reproducibility
===================

Verification requires bit reproducibility

.. figure:: img/pilotwings_repro.mp4
   :target: https://twitter.com/Foone/status/1126996260026605568

   Identical code and input, different math libraries


Floating point review
=====================

.. image:: img/IEEE_754_Double_Floating_Point_Format.svg
   :target: https://commons.wikimedia.org/wiki/File:Float_example.svg

.. math::

   (-1)^s \times 1.\{\text{frac}\}\times 2^{\{\text{exp}\}}

* Smallest fractional diff: :math:`2^{-52} \approx 2.2 \times 10^{-16}`

* 17 digits to uniquely specify a result

* Two unique representations of zero: :math:`\pm 0`

.. notes::

   Probably old news to everyone, but just as a quick review:

   Floating point numbers consist of three fields:

   - A sign bit

   - A power-of-two exponent (plus an offset)

   - A fractional field (52 bits, in double precision)

   There are a few other considerations here, like the Inf and NaN cases, or
   denormal numbers, but we don't need to discuss these for now.

   The main thing to note for now is that the smallest fractional value is
   2^-52, or about 2.2 x 10^-16.  This defines a threshhold for
   reproducibility.

   The other thing to quickly note is that both +/-0 exist in this format,
   which we'll mention later.


Addition Associativity
======================

What is :math:`10^{-16} + 1 - 1`?

.. math::

   (10^{-16} + 1) - 1 &= 0 \\
   10^{-16} + (1 - 1) &\equiv 10^{-16}

Residuals below :math:`2\times10^{-16}` may be lost.

.. notes::

   10^-16 is below the 2x10^-16 threshold, so is lost in the first summation.

   Cancellation in the second summation preserves this value.


More Addition Examples
======================

Let :math:`s = 1 + 2 \times 10^{-16}`.  What is :math:`(s + 1) - 1`?

.. math::

   s + 1 &= 2 \\
   (s + 1) - 1 &= 1 \neq s

Manipulation of :math:`s` shifted the least resolvable value.

.. notes::

   The example here is making the same point as the last one, but showing that
   the least resolvable value can change (or "float") during a calculation.

   Even though we can initially resolve the 2 x 10^-16 fraction, this fraction
   is immediately lost once we add +1 to the result, shifting the fraction.

   So it's not enough to just look for resolvable residuals, because this
   "floats" to fit the value.


.. More addition examples
   ----------------------

   * :math:`1 + 2 \times 10^{-16} - 10^{-16} = ?`

      * :math:`(1 + 2 \times 10^{-16}) - 10^{-16}
               \approx 1 + 2.2 \times 10^{-16}`
      * :math:`1 + (2 \times 10^{-16} - 10^{-16}) = 1`


Multiplication associativity
============================

If :math:`a = b = 1.5`, and :math:`c = 1 + 2^{-52}`, then

.. math::

   (a \times b) \times c &\equiv 2.25 + 2^{-51} \\
   a \times (b \times c) &\equiv 2.25 + 2^{-50}

(Actual results depend on rounding rules)

.. notes::

   Associativity of multiplication is overall less volatile, since the largest
   variations are handled in the exponent.

   The fractional part can only increase the exponent, and at most only one bit
   is lost:  (1 <= 1.xxx * 1.xxx < 4)

   But it is still revelant, and trailing bits can be lost, as seen in the
   example here.

   Note however that multiplication of the exponent 2^{exp} is a pure integer
   operation and is a reversible operation, up to over/underflow.
   (It also just happens to also manipulate the {frac}).


Sample program
--------------

.. code:: fortran

   program rounding
     use iso_fortran_env, only : real64
     implicit none

     real(kind=real64) :: a, b, c

     a = 1.5
     b = 1.5
     c = 1.0000000000000002_real64

     print '(a, es23.17)', "(a * b) * c = ", (a * b) * c
     print '(a, es23.17)', "a * (b * c) = ", a * (b * c)
   end program rounding


Integrity of parentheses
========================

V&V requires integrity of parentheses

GCC Fortran

.. code:: sh

   gfortran -fprotect-parens ...    # default
   gfortran -Ofast ...              # Sets -fno-protect-parens

Intel Fortran

.. code:: sh

   ifort -assume protect-parens     # Not default

Note: Ignoring parentheses is non-compliant!  (J3/18-007r1, 10.1.5)


.. Kahan summation
   ---------------

   Attach here? See
   https://groups.google.com/forum/#!topic/comp.lang.fortran/D-tFxYgHa_4


Parallel summation
==================

How to compute means or global sums?

1. Enforce ordering:

   .. math::

      \sum{\phi} = (\phi_1 + (\phi_2 + ( \phi_3 + ... )))

2. Fixed-precision arithmetic:

   .. image:: img/fixedprec.svg

   Hallberg and Adcroft, Parallel Computing (2014)


Associative Scaling
===================

Recall the floating point format: 

.. math:: 

   \phi \equiv (-1)^s \times 2^M \times  (1 + \alpha)

Power-of-two multiplication is associative, i.e.

.. math::

   2^N \times \phi \times 2^{-N} \equiv \phi


Dimension Scaling
=================

Rescale quantities by dimensions should be invariant:

.. math::

   u^{n+1} &= u^{n} +  \Delta t \times \text{diffu} \\
   {\color{yellow}2^{L-T}} u^{n+1} &= {\color{yellow}2^{L-T}} u^{n}
      + {\color{yellow}2^T} \Delta t
      \times {\color{yellow}2^{L - 2T}} \text{diffu}


Dimensional factors
===================

===== =======  =================
Unit  Scaling  Name
===== =======  =================
m     Z        Vertical length
m     L        Horizontal length
s     T        Time
kg/m3 R        Density
J/kg  Q        Enthalpy
===== =======  =================

.. notes::
   The currently tracked units are shown in this table.

   Enthalpy is the fundamental 


Rotational Invariance
=====================

TODO


Invariant stencils
==================

:math:`\phi^{(c)}_{i,j} = \frac{1}{4} (\phi_a + \phi_b + \phi_c + \phi_d)`

.. image:: img/stencil.svg
   :class: float

.. list-table::

   * - .. image:: img/stencil1.svg

     - :math:`\frac{1}{4} ( (\phi_A + \phi_B) + (\phi_C + \phi_D) )`

   * - .. image:: img/stencil2.svg
       
     - :math:`\frac{1}{4} ( (\phi_A + \phi_D) + (\phi_B + \phi_C) )`

.. notes::

   The ideal outcome is to construct the stencil in a rotationally invariant
   form.

   The first example will evaluate its terms in a different order after a
   quarter turn.

   The second form is rotationally invariant to any number of quarter turns.


Rotational ordering
===================

When all else fails, re-order the algorithm...

.. code:: fortran

   subroutine advect_tracer(...)
      ! ...
      x_first = modulo(turns, 2) == 1
      if (x_first) then
         call advect_x(...)
         call advect_y(...)
      else
         call advect_y(...)
         call advect_x(...)
      endif
   end subroutine advect_tracer


Negative zero?
==============

TODO?


Solution verification
=====================

``ocean.stats``::

  Step,       Day,  Truncs,      Energy/Mass,      Maximum CFL,  Mean Sea Level,  Total Mass,  Mean Salin, Mean Temp, Frac Mass Err,   Salin Err,    Temp Err
            [days]                 [m2 s-2]           [Nondim]       [m]             [kg]         [PSU]      [degC]       [Nondim]        [PSU]        [degC]
     0,       0.000,     0, En 7.2161166068132286E-27, CFL  0.00000, SL  1.8190E-12, M 1.39637E+20, S 35.0000, T 13.3483, Me  0.00E+00, Se  0.00E+00, Te  0.00E+00
    12,       0.500,     0, En 2.7781004671136538E-04, CFL  0.00011, SL  1.1369E-12, M 1.39637E+20, S 35.0000, T 13.3484, Me -6.09E-17, Se -3.90E-15, Te -1.17E-15
    24,       1.000,     0, En 2.7734897826598717E-04, CFL  0.00014, SL  1.8190E-12, M 1.39637E+20, S 35.0000, T 13.3486, Me  2.89E-17, Se  8.80E-17, Te -2.88E-16

Solution regressions are detected in total energy, mass, etc.


Diagnostic verification
=======================


``chksum_diag``::

  u-point: mean=   1.1239682303793666E-04 min=  -6.7187595818683776E-03 max=   3.3480219779204019E-02 ocean_model-u
  u-point: c=     21851 ocean_model-u
   column: mean=   1.2142284359736260E-04 min=  -3.3825897670462635E-06 max=   7.9266878285473325E-04 ocean_model-u_xyave
   column: c=       276 ocean_model-u_xyave
  u-point: mean=   3.6442721276962604E-04 min=  -6.7187595818683776E-03 max=   3.3480219779204019E-02 ocean_model_z-u
  u-point: c=     84323 ocean_model_z-u
   column: mean=   3.7252883050797810E-04 min=  -2.3761877018668929E-05 max=   7.9266878285473325E-04 ocean_model_z-u_xyave
   column: c=      1098 ocean_model_z-u_xyave
  v-point: mean=   1.2076392816784489E-03 min=  -8.3469699425156359E-03 max=   6.8420831486068704E-03 ocean_model-v
  v-point: c=     18606 ocean_model-v
   column: mean=   1.6305167686279899E-03 min=   1.3060287257008845E-03 max=   1.7892395238934757E-03 ocean_model-v_xyave
   column: c=       275 ocean_model-v_xyave
  v-point: mean=   1.4290723910598869E-03 min=  -8.3469699425156359E-03 max=   6.8420831486068704E-03 ocean_model_z-v
  v-point: c=     72299 ocean_model_z-v
   column: mean=   1.7194255440632058E-03 min=   1.3060344422280463E-03 max=   1.7948242423318677E-03 ocean_model_z-v_xyave
   column: c=      1115 ocean_model_z-v_xyave
  h-point: mean=   3.6490088139048595E+02 min=   9.9999999999999915E-04 max=   5.6265092225099863E+02 ocean_model-h
  h-point: c=     18673 ocean_model-h
   column: mean=   3.6810471584836824E+02 min=   1.2203636793942378E+02 max=   5.6250059062408047E+02 ocean_model-h_xyave
   column: c=       218 ocean_model-h_xyave
  h-point: mean=   9.4167969391093152E+01 min=   0.0000000000000000E+00 max=   5.0005664888815596E+02 ocean_model_z-h
  h-point: c=     63170 ocean_model_z-h
   column: mean=   1.3164426874862630E+02 min=   5.0000065780216882E+00 max=   5.0000001162626262E+02 ocean_model_z-h_xyave
   column: c=       847 ocean_model_z-h_xyave
  h-point: mean=  -1.7380330739934577E+03 min=  -4.4154552337742143E+03 max=   4.2186301382082547E-01 ocean_model-e
  h-point: c=     20756 ocean_model-e
   column: mean=  -1.7489127457746706E+03 min=  -2.9448377267869464E+03 max=  -2.5739527589596594E-13 ocean_model-e_xyave
   column: c=       250 ocean_model-e_xyave
  h-point: mean=  -7.3645997170533087E+02 min=  -4.4154552337742143E+03 max=   4.2186301382082547E-01 ocean_model_z-e
  h-point: c=     62532 ocean_model_z-e
   column: mean=  -7.4335128058531780E+02 min=  -2.0367396644260416E+03 max=  -2.5739527589596594E-13 ocean_model_z-e_xyave
   column: c=       830 ocean_model_z-e_xyave

Record min, max, mean, and bitcount for every diagnostic.

.. other info to mention:

   * Compute domain (no halos, no symmetric boundary)
   * Paired sums for rotational invariance
   * negative zero?


.. Test build configuration
   ========================
   
   * GCC Fortran 9.x
   * Full warnings
      * Permit float inequality with zero
   * Stack initialization
      * Signal NaN for float
      * 2^(N-1) - 1 for integer, logical


.. And the future
   ==============
   
   * Cyclomatic (McCabe) complexity
   
   * AST analyzer
   
   * Fortran lint tools (flint??)


Testing Results
===============

Over 40 issues and bugs have been detected and fixed:

TODO:

* Move these examples to the test descriptions

* Move the "over 40 bugs" comment to the conclusions


Dimensional scaling example
---------------------------

https://github.com/NOAA-GFDL/MOM6/pull/921

.. code:: fortran

   Kd_lay(i,j,k-1) = Kd_lay(i,j,k-1) + 0.5**KS_extra(i,K)
   Kd_lay(i,j,k)   = Kd_lay(i,j,k)   + 0.5**KS_extra(i,K)

:math:`\ldots + \left(\tfrac{1}{2}\right)^{\kappa_S}`?

.. notes::

   Actually discovered during implementation of the dimensional scaling, rather
   than detected by the dimensional scaling test.  But it's the sort of thing
   that would have been found...


Rotational example
------------------

https://github.com/NOAA-GFDL/MOM6/pull/1050

.. code:: fortran

   subroutine thickness_diffuse_full
      !...
      Work_u(I,j) = Work_u(I,j) + G_scale * (...)
      Work_v(i,J) = Work_v(i,J) - G_scale * (...)
      !...
   end subroutine thickness_diffuse_full


Indexing example
----------------

Assumed 1-based start index

.. code:: fortran

   subroutine register_time_deriv(...)
      real, dimension(:,:,:), target :: f_ptr
      real, dimension(:,:,:), target :: deriv_ptr
      ! ...
   end subroutine register_time_deriv

Fails for 0-based symmetric memory grids!


Another indexing example
------------------------

.. TODO: Replace with GitHub link

78d2dc3ee9a018f30bc666bd574e21fb7786403d

Extended domain to accommodate symmetric grids:

.. code:: fortran

   do J=js,je ; do i=is,ie
      h_vel = 0.5*((htot_fast(i,j) + htot_fast(i+1,j)) + h_neglect)
      uDml_diag(I,j) = uDml_diag(I,j) / (0.01*h_vel) * G%IdyCu(I,j) * (PSI(0.)-PSI(-.01))
   enddo ; enddo


.. code:: fortran

   do J=js,je ; do i=is-1,ie
      h_vel = 0.5*((htot_fast(i,j) + htot_fast(i+1,j)) + h_neglect)
      uDml_diag(I,j) = uDml_diag(I,j) / (0.01*h_vel) * G%IdyCu(I,j) * (PSI(0.)-PSI(-.01))
   enddo ; enddo




Development Guidelines
======================

0. Verification must have bit reproducibility

1. Use parentheses!

   a. Are they honored?
   b. Am I preserving residuals?

2. Use ``reproducing_sum()``

   a. Even better: Don't do global sums!

3. Use rotationally invariant stencils
