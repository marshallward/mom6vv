\==================================
Verification and Validation of MOM6
===================================

:authors:
   - Alistair Adcroft
   - Robert Hallberg
   - **Marshall Ward**
:description: An overview of the MOM6 testing framework
:date: 2020 June 8


----

**Verification**

   Am I building the product right?

**Validation**

   Am I building the right product?

Barry Boehm, *Software Risk Management* (1989)


Verification
============

What are the *design specifications* of my model?

* Does it compile on target platforms?
* Are the equations dimensionally consistent?
* Does parallelization change the answers?

*Verification is the confirmation of design specifications.*


Validation
==========

Does our model meet operational needs?

* Does it produce realistic simulations?
* Are relevant physical features present?
* Can I reproduce my old simulations?

*Validation is an assessment of the final product.*


V&V in Development
==================

.. list-table::

   * - .. figure:: img/waterfall.svg
          :width: 60%
          :target: https://en.wikipedia.org/wiki/File:Waterfall_model.svg

          Waterfall

     - .. figure:: img/v_model.svg
          :target: https://commons.wikimedia.org/wiki/File:Systems_Engineering_Process_II.svg

          V-model

.. figure:: img/agile.jpeg
   :width: 50%
   :target: https://medium.com/open-product-management/crash-article-in-agile-development-da960861259e


.. notes::

   All software development models rely on some form of verification or
   validation.

   The waterfall method (upper left) has a single stage of development, like
   building a bridge or launching a space rocket, so validation is not
   possible.  Verification must be extremely thorough.

   More iterative models like the V-model treat the development process as
   verification, and then use validation to re-define the verification steps.

   Modern Agile methods define multiple development cycles, including
   verification and validation after each "scrum".  Scrum-like methods can
   blur the distinction between verification and validation.


V&V in MOM6
===========

.. image:: img/mom_submit.svg
   :width: 20%
   :class: float

* Fork from a community repository

* Implement feature

* Submit as Pull Request™ (PR)

* Trigger V&V events

  * Automated verification

  * Manual validation

All contributions must pass verification and validation before merge.

.. notes::

   A contributer first creates a fork of the active development branch, say
   ``dev/gfdl``.

   Contributor works on their new feature.  Meanwhile, ``dev/gfdl`` is also
   evolving.

   Once completed, the contributer submits it as a Pull Request via GitHub.

   The submission must meet the design criteria of the source code.  This is
   satisfied by pass through verification and validation before being
   considered for contribution.


MOM6 Verification
=================

Verification is automatically submitted to a CI (e.g. Travis)

.. image:: img/mom_verify.svg
   :width: 50%


Verification Tests
------------------

.. TODO This is too long!

==========  =================================
Test        Description
==========  =================================
grid        Symmetric/Asymmetric memory grids
layout      1×1 and 2×1 domain decomposition
rotation    Index rotation
restart     Restart at mid-run
repro       Optimized reproducible mode
openmp      OpenMP (single-thread)
nan         NaN array initialization
dim         Dimensional scaling
==========  =================================

Each test requires bit reproducibility


Tests in Action
===============

.. list-table::

   * - .. image:: img/travis_pass.png
          :target: https://travis-ci.org/github/marshallward/MOM6/jobs/687171621

     - .. image:: img/travis_fail.png
          :target: https://travis-ci.org/github/marshallward/MOM6/jobs/687177632


MOM6 Validation
===============

.. image:: img/mom_validate.svg
   :width: 80%

Current validation includes over 60 tests

.. notes::

   This slide describes the GFDL validation process, but every center will
   customize its own validation process.

   The GFDL validation process is illustrated in this diagram.

   Only a subset of the tests are shown here, for the sake of space and
   readability.

   At least five different types of executables are required, describing
   different states of model coupling.

   All runs are tested on the GNU, Intel, and PGI compilers.

   After confirming that the code can be compiled in every case, we then run
   over sixty tests, times the number of compilers.

   Testing typically requires nearly a half hour over 30 compute nodes.

   Completion of this test ensures bit reproducibility of all very wide range
   of production runs which are considered essential to GFDL.


Hub Validation
==============

.. image:: img/gitrepos.svg
   :width: 50%

.. notes::

   Local contributions accumulate over time, becoming a ``dev/master`` PR.

   Local hub submits PR, and each hub validates the PR.

   Upon consensus, PR is merged into ``dev/master``.


Solution verification
=====================

``ocean.stats``::

  Step,       Day,  Truncs,      Energy/Mass,      Maximum CFL,  Mean Sea Level,  Total Mass,  Mean Salin, Mean Temp, Frac Mass Err,   Salin Err,    Temp Err
            [days]                 [m2 s-2]           [Nondim]       [m]             [kg]         [PSU]      [degC]       [Nondim]        [PSU]        [degC]
     0,       0.000,     0, En 7.2161166068132286E-27, CFL  0.00000, SL  1.8190E-12, M 1.39637E+20, S 35.0000, T 13.3483, Me  0.00E+00, Se  0.00E+00, Te  0.00E+00
    12,       0.500,     0, En 2.7781004671136538E-04, CFL  0.00011, SL  1.1369E-12, M 1.39637E+20, S 35.0000, T 13.3484, Me -6.09E-17, Se -3.90E-15, Te -1.17E-15
    24,       1.000,     0, En 2.7734897826598717E-04, CFL  0.00014, SL  1.8190E-12, M 1.39637E+20, S 35.0000, T 13.3486, Me  2.89E-17, Se  8.80E-17, Te -2.88E-16

Based on global metrics (energy, mass, etc)


Diagnostic verification
=======================


``chksum_diag``::

  u-point: mean=   1.1239682303793666E-04 min=  -6.7187595818683776E-03 max=   3.3480219779204019E-02 ocean_model-u
  u-point: c=     21851 ocean_model-u
   column: mean=   1.2142284359736260E-04 min=  -3.3825897670462635E-06 max=   7.9266878285473325E-04 ocean_model-u_xyave
   column: c=       276 ocean_model-u_xyave
  u-point: mean=   3.6442721276962604E-04 min=  -6.7187595818683776E-03 max=   3.3480219779204019E-02 ocean_model_z-u
  u-point: c=     84323 ocean_model_z-u
   column: mean=   3.7252883050797810E-04 min=  -2.3761877018668929E-05 max=   7.9266878285473325E-04 ocean_model_z-u_xyave
   column: c=      1098 ocean_model_z-u_xyave
  v-point: mean=   1.2076392816784489E-03 min=  -8.3469699425156359E-03 max=   6.8420831486068704E-03 ocean_model-v
  v-point: c=     18606 ocean_model-v
   column: mean=   1.6305167686279899E-03 min=   1.3060287257008845E-03 max=   1.7892395238934757E-03 ocean_model-v_xyave
   column: c=       275 ocean_model-v_xyave
  v-point: mean=   1.4290723910598869E-03 min=  -8.3469699425156359E-03 max=   6.8420831486068704E-03 ocean_model_z-v
  v-point: c=     72299 ocean_model_z-v
   column: mean=   1.7194255440632058E-03 min=   1.3060344422280463E-03 max=   1.7948242423318677E-03 ocean_model_z-v_xyave
   column: c=      1115 ocean_model_z-v_xyave
  h-point: mean=   3.6490088139048595E+02 min=   9.9999999999999915E-04 max=   5.6265092225099863E+02 ocean_model-h
  h-point: c=     18673 ocean_model-h
   column: mean=   3.6810471584836824E+02 min=   1.2203636793942378E+02 max=   5.6250059062408047E+02 ocean_model-h_xyave
   column: c=       218 ocean_model-h_xyave
  h-point: mean=   9.4167969391093152E+01 min=   0.0000000000000000E+00 max=   5.0005664888815596E+02 ocean_model_z-h
  h-point: c=     63170 ocean_model_z-h
   column: mean=   1.3164426874862630E+02 min=   5.0000065780216882E+00 max=   5.0000001162626262E+02 ocean_model_z-h_xyave
   column: c=       847 ocean_model_z-h_xyave
  h-point: mean=  -1.7380330739934577E+03 min=  -4.4154552337742143E+03 max=   4.2186301382082547E-01 ocean_model-e
  h-point: c=     20756 ocean_model-e
   column: mean=  -1.7489127457746706E+03 min=  -2.9448377267869464E+03 max=  -2.5739527589596594E-13 ocean_model-e_xyave
   column: c=       250 ocean_model-e_xyave
  h-point: mean=  -7.3645997170533087E+02 min=  -4.4154552337742143E+03 max=   4.2186301382082547E-01 ocean_model_z-e
  h-point: c=     62532 ocean_model_z-e
   column: mean=  -7.4335128058531780E+02 min=  -2.0367396644260416E+03 max=  -2.5739527589596594E-13 ocean_model_z-e_xyave
   column: c=       830 ocean_model_z-e_xyave

Min, max, mean, bitcount for every diagnostic

Bit Reproducibility
===================

Verification requires bit reproducibility

.. figure:: img/pilotwings_repro.mp4
   :target: https://twitter.com/Foone/status/1126996260026605568

   Identical code and input, different math libraries

.. notes::

   This is two instances of the opening demo of the 1991 Super Nintendo game,
   "Pilotwings".

   In the initial release, the plane would make a graceful landing.  But in a
   later version, the plan would crash spectacularly.

   People later inspected the data and discovered that the instruction code was
   identical.  So what happenend?

   The cartridge included a mathematical coprocessor (NEC DSP-1) for its 3D
   calculations.  The second iteration of the coprocessor (DSP-1b) reordered
   some of its arithmetic to improve the accuracy of various calculations.

   Unfortunately this also resulted in tiny course corrections in the flight,
   which eventually led to the demise of the biplane in the video.

   The moral of the story is that when working with limited precision, one must
   be very careful!

   (Confession: this was fixed-precision arithmetic, but it's basically the
   same problem.)


Floating Point Review
=====================

.. image:: img/IEEE_754_Double_Floating_Point_Format.svg
   :target: https://commons.wikimedia.org/wiki/File:Float_example.svg

.. math::

   (-1)^s \times 1.\{\text{frac}\}\times 2^{\{\text{exp}\}}

* Smallest fractional diff: :math:`2^{-52} \approx 2.2 \times 10^{-16}`

* 17 digits to uniquely specify a result

* Two unique representations of zero: :math:`\pm 0`

.. notes::

   Probably old news to everyone, but just as a quick review:

   Floating point numbers consist of three fields:

   - A sign bit

   - A power-of-two exponent (plus an offset)

   - A fractional field (52 bits, in double precision)

   There are a few other considerations here, like the Inf and NaN cases, or
   denormal numbers, but we don't need to discuss these for now.

   The main thing to note for now is that the smallest fractional value is
   2^-52, or about 2.2 x 10^-16.  This defines a threshhold for
   reproducibility.

   The other thing to quickly note is that both +/-0 exist in this format,
   which we'll mention later.


Addition Associativity
======================

What is :math:`10^{-16} + 1 - 1`?

.. math::

   (10^{-16} + 1) - 1 &= 0 \\
   10^{-16} + (1 - 1) &\equiv 10^{-16}

Residuals below :math:`2\times10^{-16}` may be lost.

.. notes::

   10^-16 is below the 2x10^-16 threshold, so is lost in the first summation.

   Cancellation in the second summation preserves this value.


More Addition Examples
======================

Let :math:`s = 1 + 2 \times 10^{-16}`.  What is :math:`(s + 1) - 1`?

.. math::

   s + 1 &= 2 \\
   (s + 1) - 1 &= 1 \neq s

Manipulation of :math:`s` shifted the least resolvable value.

.. notes::

   The example here is making the same point as the last one, but showing that
   the least resolvable value can change (or "float") during a calculation.

   Even though we can initially resolve the 2 x 10^-16 fraction, this fraction
   is immediately lost once we add +1 to the result, shifting the fraction.

   So it's not enough to just look for resolvable residuals, because this
   "floats" to fit the value.


.. More addition examples
   ----------------------

   * :math:`1 + 2 \times 10^{-16} - 10^{-16} = ?`

      * :math:`(1 + 2 \times 10^{-16}) - 10^{-16}
               \approx 1 + 2.2 \times 10^{-16}`
      * :math:`1 + (2 \times 10^{-16} - 10^{-16}) = 1`


Multiplication associativity
============================

If :math:`a = b = 1.5`, and :math:`c = 1 + 2^{-52}`, then

.. math::

   (a \times b) \times c &\equiv 2.25 + 2^{-51} \\
   a \times (b \times c) &\equiv 2.25 + 2^{-50}

(Actual results depend on rounding rules)

.. notes::

   Associativity of multiplication is overall less volatile, since the largest
   variations are handled in the exponent.

   The fractional part can only increase the exponent, and at most only one bit
   is lost:  (1 <= 1.xxx * 1.xxx < 4)

   But it is still revelant, and trailing bits can be lost, as seen in the
   example here.

   Note however that multiplication of the exponent 2^{exp} is a pure integer
   operation and is a reversible operation, up to over/underflow.
   (It also just happens to also manipulate the {frac}).


Sample program
--------------

.. code:: fortran

   program rounding
     use iso_fortran_env, only : real64
     implicit none

     real(kind=real64) :: a, b, c

     a = 1.5
     b = 1.5
     c = 1.0000000000000002_real64

     print '(a, es23.17)', "(a * b) * c = ", (a * b) * c
     print '(a, es23.17)', "a * (b * c) = ", a * (b * c)
   end program rounding


Integrity of parentheses
========================

V&V requires integrity of parentheses

GCC Fortran

.. code:: sh

   gfortran -fprotect-parens ...    # default
   gfortran -Ofast ...              # Sets -fno-protect-parens

Intel Fortran

.. code:: sh

   ifort -assume protect-parens     # Not default

Note: Ignoring parentheses is non-compliant!  (J3/18-007r1, 10.1.5)


.. Kahan summation
   ---------------

   Attach here? See
   https://groups.google.com/forum/#!topic/comp.lang.fortran/D-tFxYgHa_4


Division Performance
====================

Minimize division operations:

.. code:: fortran

   x = a / b / c           ! Bad
   x = a / (b * c)         ! Good

   y = 1. / (1. + 1./c)    ! Bad
   y = c / (c + 1.)        ! Good

Store common divisions:

.. code:: fortran

   I_dx = 1.0 / dx
   dudx = I_dx * (u(i+1) - u(i))
   dvdx = I_dx * (v(i+1) - v(i))

Divisions are slower and more unpredictable


Parallel summation
==================

How to compute reproducible means or global sums?

* Enforce ordering

  .. math::

     \sum{\phi} = (\phi_1 + (\phi_2 + ( \phi_3 + ... )))

* Fixed-precision arithmetic

  .. image:: img/fixedprec.svg
     :target: https://doi.org/10.1016/j.parco.2014.04.007

.. Hallberg and Adcroft, Parallel Computing (2014)


Associative Scaling
===================

Recall the floating point format

.. math::

   \phi \equiv (-1)^{\color{yellow}s} \times 2^{\color{yellow}M}
      \times (1 + {\color{yellow}\alpha})

Power-of-two multiplication is associative

.. math::

   2^N \times \phi \times 2^{-N} \equiv \phi


Dimension Scaling
=================

Fields rescaled by dimensions should be invariant

.. math::

   u^{n+1} &= u^{n} +  \Delta t \times \mathcal{F} \\
   {\color{yellow}2^{L-T}} u^{n+1} &= {\color{yellow}2^{L-T}} u^{n}
      + {\color{yellow}2^T} \Delta t
      \times {\color{yellow}2^{L - 2T}} \mathcal{F}


Dimensional factors
-------------------

===== =======  =================
Unit  Scaling  Name
===== =======  =================
s     T        Time
m     L        Horizontal length
m     H        Layer thickness
m     Z        Vertical length
kg/m3 R        Density
J/kg  Q        Enthalpy
===== =======  =================

.. notes::

   The currently tracked units are shown in this table.


Defining Dimensions
===================

Input parameters

.. code::

   call get_param(... , "DT", ... , scale=US%s_to_T)

Explicit constants

.. code:: fortran

   eps_vel = 1.0e-10 * US%m_s_to_L_T
   ustar = 0.01 * US%m_to_Z * US%T_to_s

Diagnostic registration

.. code::

   call register_diag_field(..., "u", ... , conversion=US%L_T_to_m_s)


.. notes::

   The intention is that all variables will be immediately converted from MKS
   to rescaled units, and manipulated in rescaled form, and then converted back
   to MKS on output (typically as diagnostic).

   The exception is any hard-coded dimensional constants, such as a minimum
   threshold velocity or perhaps a ustar in some mixing algorithm.

   For the most part, Bob has completed this work, and all equations are being
   tested for dimensional consistency.

   But if for some reason something has not been scaled, it is possible to
   rescale and descale any intermediate variables.


Rotational Invariance
=====================

Solutions must be invariant to **index rotation**, e.g.:

.. math::

   \phi(i',j') = \phi(j, N-i)

Both *fields* and *coordinates* are remapped.

Note: :math:`u` and :math:`v` are velocities along :math:`i` and :math:`j`!

Stencils are not rotated!


Index Rotation
==============

.. list-table::

   * - .. image:: img/rotate_grid1.svg
          :width: 70%

     - .. image:: img/rotate_grid2.svg
          :width: 70%

.. image:: img/rotate_mem.svg
          :width: 65%


.. notes::

   I call it an "index rotation" here since there is no physical rotation of
   the system here.

   No physical rotation is ever applied to the system, neither the fields
   themselves nor the coordinates.




   What is being rotated is the index map of the fields.



   Everything here is rotated: the fields, the topographies, the forcings, even
   the coordinates.  The net result is nothing is r




Invariant stencils
==================

:math:`\phi^{(c)}_{i,j} = \frac{1}{4} (\phi_A + \phi_B + \phi_C + \phi_D)`

.. image:: img/stencil.svg
   :class: float

.. list-table::

   * - .. image:: img/stencil1.svg

     - :math:`\frac{1}{4} ( (\phi_A + \phi_B) + (\phi_C + \phi_D) )`

   * - .. image:: img/stencil2.svg

     - :math:`\frac{1}{4} ( (\phi_A + \phi_D) + (\phi_B + \phi_C) )`

.. notes::

   The ideal outcome is to construct the stencil in a rotationally invariant
   form.

   The first example will evaluate its terms in a different order after a
   quarter turn.

   The second form is rotationally invariant to any number of quarter turns.


Rotational ordering
===================

When all else fails, reorder the algorithm:

.. code:: fortran

   subroutine advect_tracer(...)
      ! ...
      x_first = modulo(turns, 2) == 1
      if (x_first) then
         call advect_x(...)
         call advect_y(...)
      else
         call advect_y(...)
         call advect_x(...)
      endif
   end subroutine advect_tracer


Negative zero?
==============

TODO?


.. other info to mention:

   * Compute domain (no halos, no symmetric boundary)
   * Paired sums for rotational invariance
   * negative zero?


.. Test build configuration
   ========================

   * GCC Fortran 9.x
   * Full warnings
      * Permit float inequality with zero
   * Stack initialization
      * Signal NaN for float
      * 2^(N-1) - 1 for integer, logical


.. And the future
   ==============

   * Cyclomatic (McCabe) complexity

   * AST analyzer

   * Fortran lint tools (flint??)


Testing Results
===============

Over 40 issues and bugs have been detected and fixed:

TODO:

* Move these examples to the test descriptions

* Move the "over 40 bugs" comment to the conclusions


Dimensional scaling example
---------------------------

https://github.com/NOAA-GFDL/MOM6/pull/921

.. code:: fortran

   Kd_lay(i,j,k-1) = Kd_lay(i,j,k-1) + 0.5**KS_extra(i,K)
   Kd_lay(i,j,k)   = Kd_lay(i,j,k)   + 0.5**KS_extra(i,K)

:math:`\ldots + \left(\tfrac{1}{2}\right)^{\kappa_S}`?

.. notes::

   Actually discovered during implementation of the dimensional scaling, rather
   than detected by the dimensional scaling test.  But it's the sort of thing
   that would have been found...


Rotational example
------------------

https://github.com/NOAA-GFDL/MOM6/pull/1050

.. code:: fortran

   subroutine thickness_diffuse_full
      !...
      Work_u(I,j) = Work_u(I,j) + G_scale * (...)
      Work_v(i,J) = Work_v(i,J) - G_scale * (...)
      !...
   end subroutine thickness_diffuse_full


Indexing example
----------------

Assumed 1-based start index

.. code:: fortran

   subroutine register_time_deriv(...)
      real, dimension(:,:,:), target :: f_ptr
      real, dimension(:,:,:), target :: deriv_ptr
      ! ...
   end subroutine register_time_deriv

Fails for 0-based symmetric memory grids!


Another indexing example
------------------------

.. TODO: Replace with GitHub link

78d2dc3ee9a018f30bc666bd574e21fb7786403d

Extended domain to accommodate symmetric grids:

.. code:: fortran

   do J=js,je ; do i=is,ie
      h_vel = 0.5*((htot_fast(i,j) + htot_fast(i+1,j)) + h_neglect)
      uDml_diag(I,j) = uDml_diag(I,j) / (0.01*h_vel) * G%IdyCu(I,j) * (PSI(0.)-PSI(-.01))
   enddo ; enddo


.. code:: fortran

   do J=js,je ; do i=is-1,ie
      h_vel = 0.5*((htot_fast(i,j) + htot_fast(i+1,j)) + h_neglect)
      uDml_diag(I,j) = uDml_diag(I,j) / (0.01*h_vel) * G%IdyCu(I,j) * (PSI(0.)-PSI(-.01))
   enddo ; enddo




Development Guidelines
======================

0. Verification must have bit reproducibility

1. Use parentheses!

   a. Are they honored?
   b. Am I preserving residuals?

2. Use ``reproducing_sum()``

   a. Even better: Don't do global sums!

3. Register dimensions

4. Use rotationally invariant stencils
